Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement EOL programme
Rule 3     statement -> assignation
Rule 4     statement -> structure
Rule 5     statement -> function
Rule 6     structure -> WHILE expression { programme }
Rule 7     structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
Rule 8     structure -> IF expression { programme }
Rule 9     structure -> BULLETEDLIST { programme }
Rule 10    structure -> ARRAY { programme }
Rule 11    structure -> ARRAYHEADER { programme }
Rule 12    structure -> ARRAYROW { programme }
Rule 13    expression -> ( expression )
Rule 14    expression -> NUMBER
Rule 15    expression -> IDENTIFIER
Rule 16    expression -> STRING
Rule 17    expression -> expression ADD_OP expression
Rule 18    expression -> expression MUL_OP expression
Rule 19    expression -> expression COMP_OP expression
Rule 20    assignation -> IDENTIFIER = expression
Rule 21    parameter -> expression
Rule 22    parameter -> expression , parameter
Rule 23    function -> IDENTIFIER ( parameter )

Terminals, with rules where they appear

(                    : 13 23
)                    : 13 23
,                    : 22
=                    : 20
ADD_OP               : 17
ARRAY                : 10
ARRAYHEADER          : 11
ARRAYROW             : 12
BULLETEDLIST         : 9
COMP_OP              : 19
EOL                  : 2
FOR                  : 7
FROM                 : 7
IDENTIFIER           : 7 15 20 23
IF                   : 8
MUL_OP               : 18
NUMBER               : 7 7 14
STRING               : 16
TO                   : 7
WHILE                : 6
error                : 
{                    : 6 7 8 9 10 11 12
}                    : 6 7 8 9 10 11 12

Nonterminals, with rules where they appear

assignation          : 3
expression           : 6 8 13 17 17 18 18 19 19 20 21 22
function             : 5
parameter            : 22 23
programme            : 2 6 7 8 9 10 11 12 0
statement            : 1 2
structure            : 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . EOL programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    EOL             shift and go to state 14


state 3

    (3) statement -> assignation .

    EOL             reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> structure .

    EOL             reduce using rule 4 (statement -> structure .)
    $end            reduce using rule 4 (statement -> structure .)
    }               reduce using rule 4 (statement -> structure .)


state 5

    (5) statement -> function .

    EOL             reduce using rule 5 (statement -> function .)
    $end            reduce using rule 5 (statement -> function .)
    }               reduce using rule 5 (statement -> function .)


state 6

    (20) assignation -> IDENTIFIER . = expression
    (23) function -> IDENTIFIER . ( parameter )

    =               shift and go to state 15
    (               shift and go to state 16


state 7

    (6) structure -> WHILE . expression { programme }
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 17

state 8

    (7) structure -> FOR . IDENTIFIER FROM NUMBER TO NUMBER { programme }

    IDENTIFIER      shift and go to state 22


state 9

    (8) structure -> IF . expression { programme }
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 23

state 10

    (9) structure -> BULLETEDLIST . { programme }

    {               shift and go to state 24


state 11

    (10) structure -> ARRAY . { programme }

    {               shift and go to state 25


state 12

    (11) structure -> ARRAYHEADER . { programme }

    {               shift and go to state 26


state 13

    (12) structure -> ARRAYROW . { programme }

    {               shift and go to state 27


state 14

    (2) programme -> statement EOL . programme
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    statement                      shift and go to state 2
    programme                      shift and go to state 28
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 15

    (20) assignation -> IDENTIFIER = . expression
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 29

state 16

    (23) function -> IDENTIFIER ( . parameter )
    (21) parameter -> . expression
    (22) parameter -> . expression , parameter
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    parameter                      shift and go to state 30
    expression                     shift and go to state 31

state 17

    (6) structure -> WHILE expression . { programme }
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

    {               shift and go to state 32
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35


state 18

    (13) expression -> ( . expression )
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 36

state 19

    (14) expression -> NUMBER .

    {               reduce using rule 14 (expression -> NUMBER .)
    ADD_OP          reduce using rule 14 (expression -> NUMBER .)
    MUL_OP          reduce using rule 14 (expression -> NUMBER .)
    COMP_OP         reduce using rule 14 (expression -> NUMBER .)
    EOL             reduce using rule 14 (expression -> NUMBER .)
    $end            reduce using rule 14 (expression -> NUMBER .)
    }               reduce using rule 14 (expression -> NUMBER .)
    ,               reduce using rule 14 (expression -> NUMBER .)
    )               reduce using rule 14 (expression -> NUMBER .)


state 20

    (15) expression -> IDENTIFIER .

    {               reduce using rule 15 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 15 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 15 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 15 (expression -> IDENTIFIER .)
    EOL             reduce using rule 15 (expression -> IDENTIFIER .)
    $end            reduce using rule 15 (expression -> IDENTIFIER .)
    }               reduce using rule 15 (expression -> IDENTIFIER .)
    ,               reduce using rule 15 (expression -> IDENTIFIER .)
    )               reduce using rule 15 (expression -> IDENTIFIER .)


state 21

    (16) expression -> STRING .

    {               reduce using rule 16 (expression -> STRING .)
    ADD_OP          reduce using rule 16 (expression -> STRING .)
    MUL_OP          reduce using rule 16 (expression -> STRING .)
    COMP_OP         reduce using rule 16 (expression -> STRING .)
    EOL             reduce using rule 16 (expression -> STRING .)
    $end            reduce using rule 16 (expression -> STRING .)
    }               reduce using rule 16 (expression -> STRING .)
    ,               reduce using rule 16 (expression -> STRING .)
    )               reduce using rule 16 (expression -> STRING .)


state 22

    (7) structure -> FOR IDENTIFIER . FROM NUMBER TO NUMBER { programme }

    FROM            shift and go to state 37


state 23

    (8) structure -> IF expression . { programme }
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

    {               shift and go to state 38
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35


state 24

    (9) structure -> BULLETEDLIST { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 39
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 25

    (10) structure -> ARRAY { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 40
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 26

    (11) structure -> ARRAYHEADER { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 41
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 27

    (12) structure -> ARRAYROW { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 42
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 28

    (2) programme -> statement EOL programme .

    $end            reduce using rule 2 (programme -> statement EOL programme .)
    }               reduce using rule 2 (programme -> statement EOL programme .)


state 29

    (20) assignation -> IDENTIFIER = expression .
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

    EOL             reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 20 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35


state 30

    (23) function -> IDENTIFIER ( parameter . )

    )               shift and go to state 43


state 31

    (21) parameter -> expression .
    (22) parameter -> expression . , parameter
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

    )               reduce using rule 21 (parameter -> expression .)
    ,               shift and go to state 44
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35


state 32

    (6) structure -> WHILE expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 45
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 33

    (17) expression -> expression ADD_OP . expression
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 46

state 34

    (18) expression -> expression MUL_OP . expression
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 47

state 35

    (19) expression -> expression COMP_OP . expression
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 48

state 36

    (13) expression -> ( expression . )
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

    )               shift and go to state 49
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35


state 37

    (7) structure -> FOR IDENTIFIER FROM . NUMBER TO NUMBER { programme }

    NUMBER          shift and go to state 50


state 38

    (8) structure -> IF expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 51
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 39

    (9) structure -> BULLETEDLIST { programme . }

    }               shift and go to state 52


state 40

    (10) structure -> ARRAY { programme . }

    }               shift and go to state 53


state 41

    (11) structure -> ARRAYHEADER { programme . }

    }               shift and go to state 54


state 42

    (12) structure -> ARRAYROW { programme . }

    }               shift and go to state 55


state 43

    (23) function -> IDENTIFIER ( parameter ) .

    EOL             reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    $end            reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    }               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)


state 44

    (22) parameter -> expression , . parameter
    (21) parameter -> . expression
    (22) parameter -> . expression , parameter
    (13) expression -> . ( expression )
    (14) expression -> . NUMBER
    (15) expression -> . IDENTIFIER
    (16) expression -> . STRING
    (17) expression -> . expression ADD_OP expression
    (18) expression -> . expression MUL_OP expression
    (19) expression -> . expression COMP_OP expression

    (               shift and go to state 18
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    STRING          shift and go to state 21

    expression                     shift and go to state 31
    parameter                      shift and go to state 56

state 45

    (6) structure -> WHILE expression { programme . }

    }               shift and go to state 57


state 46

    (17) expression -> expression ADD_OP expression .
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for COMP_OP resolved as shift
    {               reduce using rule 17 (expression -> expression ADD_OP expression .)
    EOL             reduce using rule 17 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 17 (expression -> expression ADD_OP expression .)
    }               reduce using rule 17 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 17 (expression -> expression ADD_OP expression .)
    )               reduce using rule 17 (expression -> expression ADD_OP expression .)
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35

  ! ADD_OP          [ reduce using rule 17 (expression -> expression ADD_OP expression .) ]
  ! MUL_OP          [ reduce using rule 17 (expression -> expression ADD_OP expression .) ]
  ! COMP_OP         [ reduce using rule 17 (expression -> expression ADD_OP expression .) ]


state 47

    (18) expression -> expression MUL_OP expression .
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for COMP_OP resolved as shift
    {               reduce using rule 18 (expression -> expression MUL_OP expression .)
    EOL             reduce using rule 18 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 18 (expression -> expression MUL_OP expression .)
    }               reduce using rule 18 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 18 (expression -> expression MUL_OP expression .)
    )               reduce using rule 18 (expression -> expression MUL_OP expression .)
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35

  ! ADD_OP          [ reduce using rule 18 (expression -> expression MUL_OP expression .) ]
  ! MUL_OP          [ reduce using rule 18 (expression -> expression MUL_OP expression .) ]
  ! COMP_OP         [ reduce using rule 18 (expression -> expression MUL_OP expression .) ]


state 48

    (19) expression -> expression COMP_OP expression .
    (17) expression -> expression . ADD_OP expression
    (18) expression -> expression . MUL_OP expression
    (19) expression -> expression . COMP_OP expression

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for COMP_OP resolved as shift
    {               reduce using rule 19 (expression -> expression COMP_OP expression .)
    EOL             reduce using rule 19 (expression -> expression COMP_OP expression .)
    $end            reduce using rule 19 (expression -> expression COMP_OP expression .)
    }               reduce using rule 19 (expression -> expression COMP_OP expression .)
    ,               reduce using rule 19 (expression -> expression COMP_OP expression .)
    )               reduce using rule 19 (expression -> expression COMP_OP expression .)
    ADD_OP          shift and go to state 33
    MUL_OP          shift and go to state 34
    COMP_OP         shift and go to state 35

  ! ADD_OP          [ reduce using rule 19 (expression -> expression COMP_OP expression .) ]
  ! MUL_OP          [ reduce using rule 19 (expression -> expression COMP_OP expression .) ]
  ! COMP_OP         [ reduce using rule 19 (expression -> expression COMP_OP expression .) ]


state 49

    (13) expression -> ( expression ) .

    {               reduce using rule 13 (expression -> ( expression ) .)
    ADD_OP          reduce using rule 13 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 13 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 13 (expression -> ( expression ) .)
    EOL             reduce using rule 13 (expression -> ( expression ) .)
    $end            reduce using rule 13 (expression -> ( expression ) .)
    }               reduce using rule 13 (expression -> ( expression ) .)
    ,               reduce using rule 13 (expression -> ( expression ) .)
    )               reduce using rule 13 (expression -> ( expression ) .)


state 50

    (7) structure -> FOR IDENTIFIER FROM NUMBER . TO NUMBER { programme }

    TO              shift and go to state 58


state 51

    (8) structure -> IF expression { programme . }

    }               shift and go to state 59


state 52

    (9) structure -> BULLETEDLIST { programme } .

    EOL             reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    $end            reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    }               reduce using rule 9 (structure -> BULLETEDLIST { programme } .)


state 53

    (10) structure -> ARRAY { programme } .

    EOL             reduce using rule 10 (structure -> ARRAY { programme } .)
    $end            reduce using rule 10 (structure -> ARRAY { programme } .)
    }               reduce using rule 10 (structure -> ARRAY { programme } .)


state 54

    (11) structure -> ARRAYHEADER { programme } .

    EOL             reduce using rule 11 (structure -> ARRAYHEADER { programme } .)
    $end            reduce using rule 11 (structure -> ARRAYHEADER { programme } .)
    }               reduce using rule 11 (structure -> ARRAYHEADER { programme } .)


state 55

    (12) structure -> ARRAYROW { programme } .

    EOL             reduce using rule 12 (structure -> ARRAYROW { programme } .)
    $end            reduce using rule 12 (structure -> ARRAYROW { programme } .)
    }               reduce using rule 12 (structure -> ARRAYROW { programme } .)


state 56

    (22) parameter -> expression , parameter .

    )               reduce using rule 22 (parameter -> expression , parameter .)


state 57

    (6) structure -> WHILE expression { programme } .

    EOL             reduce using rule 6 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 6 (structure -> WHILE expression { programme } .)
    }               reduce using rule 6 (structure -> WHILE expression { programme } .)


state 58

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO . NUMBER { programme }

    NUMBER          shift and go to state 60


state 59

    (8) structure -> IF expression { programme } .

    EOL             reduce using rule 8 (structure -> IF expression { programme } .)
    $end            reduce using rule 8 (structure -> IF expression { programme } .)
    }               reduce using rule 8 (structure -> IF expression { programme } .)


state 60

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER . { programme }

    {               shift and go to state 61


state 61

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { . programme }
    (1) programme -> . statement
    (2) programme -> . statement EOL programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (20) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYHEADER { programme }
    (12) structure -> . ARRAYROW { programme }
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYHEADER     shift and go to state 12
    ARRAYROW        shift and go to state 13

    programme                      shift and go to state 62
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 62

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme . }

    }               shift and go to state 63


state 63

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .

    EOL             reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)
    $end            reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)
    }               reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD_OP in state 46 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 46 resolved as shift
WARNING: shift/reduce conflict for COMP_OP in state 46 resolved as shift
WARNING: shift/reduce conflict for ADD_OP in state 47 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 47 resolved as shift
WARNING: shift/reduce conflict for COMP_OP in state 47 resolved as shift
WARNING: shift/reduce conflict for ADD_OP in state 48 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 48 resolved as shift
WARNING: shift/reduce conflict for COMP_OP in state 48 resolved as shift
