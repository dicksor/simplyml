Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> expression
Rule 5     statement -> structure
Rule 6     structure -> WHILE expression { programme }
Rule 7     structure -> FOR IDENTIFIER FROM expression TO expression { programme }
Rule 8     structure -> IF expression { programme }
Rule 9     structure -> BULLETEDLIST { programme }
Rule 10    structure -> TABLE { programme }
Rule 11    structure -> TABLEROW { programme }
Rule 12    expression -> ( expression )
Rule 13    expression -> NUMBER
Rule 14    expression -> STRING
Rule 15    expression -> array
Rule 16    expression -> function
Rule 17    expression -> IDENTIFIER
Rule 18    expression -> expression ADD_OP expression
Rule 19    expression -> expression MUL_OP expression
Rule 20    expression -> expression COMP_OP expression
Rule 21    assignation -> IDENTIFIER = expression
Rule 22    array -> [ parameter ]
Rule 23    function -> IDENTIFIER ( parameter )
Rule 24    expression -> IDENTIFIER [ IDENTIFIER ]
Rule 25    parameter -> expression
Rule 26    parameter -> expression , parameter

Terminals, with rules where they appear

(                    : 12 23
)                    : 12 23
,                    : 26
;                    : 2
=                    : 21
ADD_OP               : 18
BULLETEDLIST         : 9
COMP_OP              : 20
FOR                  : 7
FROM                 : 7
IDENTIFIER           : 7 17 21 23 24 24
IF                   : 8
MUL_OP               : 19
NUMBER               : 13
STRING               : 14
TABLE                : 10
TABLEROW             : 11
TO                   : 7
WHILE                : 6
[                    : 22 24
]                    : 22 24
error                : 
{                    : 6 7 8 9 10 11
}                    : 6 7 8 9 10 11

Nonterminals, with rules where they appear

array                : 15
assignation          : 3
expression           : 4 6 7 7 8 12 18 18 19 19 20 20 21 25 26
function             : 16
parameter            : 22 23 26
programme            : 2 6 7 8 9 10 11 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    expression                     shift and go to state 4
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 19


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    ;               reduce using rule 4 (statement -> expression .)
    $end            reduce using rule 4 (statement -> expression .)
    }               reduce using rule 4 (statement -> expression .)
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (21) assignation -> IDENTIFIER . = expression
    (17) expression -> IDENTIFIER .
    (24) expression -> IDENTIFIER . [ IDENTIFIER ]
    (23) function -> IDENTIFIER . ( parameter )

    =               shift and go to state 23
    ADD_OP          reduce using rule 17 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 17 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 17 (expression -> IDENTIFIER .)
    ;               reduce using rule 17 (expression -> IDENTIFIER .)
    $end            reduce using rule 17 (expression -> IDENTIFIER .)
    }               reduce using rule 17 (expression -> IDENTIFIER .)
    [               shift and go to state 24
    (               shift and go to state 25


state 7

    (12) expression -> ( . expression )
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 26
    array                          shift and go to state 10
    function                       shift and go to state 11

state 8

    (13) expression -> NUMBER .

    ADD_OP          reduce using rule 13 (expression -> NUMBER .)
    MUL_OP          reduce using rule 13 (expression -> NUMBER .)
    COMP_OP         reduce using rule 13 (expression -> NUMBER .)
    ;               reduce using rule 13 (expression -> NUMBER .)
    $end            reduce using rule 13 (expression -> NUMBER .)
    )               reduce using rule 13 (expression -> NUMBER .)
    ,               reduce using rule 13 (expression -> NUMBER .)
    ]               reduce using rule 13 (expression -> NUMBER .)
    {               reduce using rule 13 (expression -> NUMBER .)
    }               reduce using rule 13 (expression -> NUMBER .)
    TO              reduce using rule 13 (expression -> NUMBER .)


state 9

    (14) expression -> STRING .

    ADD_OP          reduce using rule 14 (expression -> STRING .)
    MUL_OP          reduce using rule 14 (expression -> STRING .)
    COMP_OP         reduce using rule 14 (expression -> STRING .)
    ;               reduce using rule 14 (expression -> STRING .)
    $end            reduce using rule 14 (expression -> STRING .)
    )               reduce using rule 14 (expression -> STRING .)
    ,               reduce using rule 14 (expression -> STRING .)
    ]               reduce using rule 14 (expression -> STRING .)
    {               reduce using rule 14 (expression -> STRING .)
    }               reduce using rule 14 (expression -> STRING .)
    TO              reduce using rule 14 (expression -> STRING .)


state 10

    (15) expression -> array .

    ADD_OP          reduce using rule 15 (expression -> array .)
    MUL_OP          reduce using rule 15 (expression -> array .)
    COMP_OP         reduce using rule 15 (expression -> array .)
    ;               reduce using rule 15 (expression -> array .)
    $end            reduce using rule 15 (expression -> array .)
    )               reduce using rule 15 (expression -> array .)
    ,               reduce using rule 15 (expression -> array .)
    ]               reduce using rule 15 (expression -> array .)
    {               reduce using rule 15 (expression -> array .)
    }               reduce using rule 15 (expression -> array .)
    TO              reduce using rule 15 (expression -> array .)


state 11

    (16) expression -> function .

    ADD_OP          reduce using rule 16 (expression -> function .)
    MUL_OP          reduce using rule 16 (expression -> function .)
    COMP_OP         reduce using rule 16 (expression -> function .)
    ;               reduce using rule 16 (expression -> function .)
    $end            reduce using rule 16 (expression -> function .)
    )               reduce using rule 16 (expression -> function .)
    ,               reduce using rule 16 (expression -> function .)
    ]               reduce using rule 16 (expression -> function .)
    {               reduce using rule 16 (expression -> function .)
    }               reduce using rule 16 (expression -> function .)
    TO              reduce using rule 16 (expression -> function .)


state 12

    (22) array -> [ . parameter ]
    (25) parameter -> . expression
    (26) parameter -> . expression , parameter
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    parameter                      shift and go to state 28
    expression                     shift and go to state 29
    array                          shift and go to state 10
    function                       shift and go to state 11

state 13

    (6) structure -> WHILE . expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 30
    array                          shift and go to state 10
    function                       shift and go to state 11

state 14

    (7) structure -> FOR . IDENTIFIER FROM expression TO expression { programme }

    IDENTIFIER      shift and go to state 31


state 15

    (8) structure -> IF . expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 32
    array                          shift and go to state 10
    function                       shift and go to state 11

state 16

    (9) structure -> BULLETEDLIST . { programme }

    {               shift and go to state 33


state 17

    (10) structure -> TABLE . { programme }

    {               shift and go to state 34


state 18

    (11) structure -> TABLEROW . { programme }

    {               shift and go to state 35


state 19

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    statement                      shift and go to state 2
    programme                      shift and go to state 36
    assignation                    shift and go to state 3
    expression                     shift and go to state 4
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 20

    (18) expression -> expression ADD_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 37
    array                          shift and go to state 10
    function                       shift and go to state 11

state 21

    (19) expression -> expression MUL_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 38
    array                          shift and go to state 10
    function                       shift and go to state 11

state 22

    (20) expression -> expression COMP_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 39
    array                          shift and go to state 10
    function                       shift and go to state 11

state 23

    (21) assignation -> IDENTIFIER = . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 40
    array                          shift and go to state 10
    function                       shift and go to state 11

state 24

    (24) expression -> IDENTIFIER [ . IDENTIFIER ]

    IDENTIFIER      shift and go to state 41


state 25

    (23) function -> IDENTIFIER ( . parameter )
    (25) parameter -> . expression
    (26) parameter -> . expression , parameter
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    parameter                      shift and go to state 42
    expression                     shift and go to state 29
    array                          shift and go to state 10
    function                       shift and go to state 11

state 26

    (12) expression -> ( expression . )
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    )               shift and go to state 43
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 27

    (17) expression -> IDENTIFIER .
    (24) expression -> IDENTIFIER . [ IDENTIFIER ]
    (23) function -> IDENTIFIER . ( parameter )

    )               reduce using rule 17 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 17 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 17 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 17 (expression -> IDENTIFIER .)
    ,               reduce using rule 17 (expression -> IDENTIFIER .)
    ]               reduce using rule 17 (expression -> IDENTIFIER .)
    {               reduce using rule 17 (expression -> IDENTIFIER .)
    ;               reduce using rule 17 (expression -> IDENTIFIER .)
    $end            reduce using rule 17 (expression -> IDENTIFIER .)
    }               reduce using rule 17 (expression -> IDENTIFIER .)
    TO              reduce using rule 17 (expression -> IDENTIFIER .)
    [               shift and go to state 24
    (               shift and go to state 25


state 28

    (22) array -> [ parameter . ]

    ]               shift and go to state 44


state 29

    (25) parameter -> expression .
    (26) parameter -> expression . , parameter
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    ]               reduce using rule 25 (parameter -> expression .)
    )               reduce using rule 25 (parameter -> expression .)
    ,               shift and go to state 45
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 30

    (6) structure -> WHILE expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    {               shift and go to state 46
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 31

    (7) structure -> FOR IDENTIFIER . FROM expression TO expression { programme }

    FROM            shift and go to state 47


state 32

    (8) structure -> IF expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    {               shift and go to state 48
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 33

    (9) structure -> BULLETEDLIST { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    programme                      shift and go to state 49
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    expression                     shift and go to state 4
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 34

    (10) structure -> TABLE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    programme                      shift and go to state 50
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    expression                     shift and go to state 4
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 35

    (11) structure -> TABLEROW { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    programme                      shift and go to state 51
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    expression                     shift and go to state 4
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 36

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 37

    (18) expression -> expression ADD_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 18 (expression -> expression ADD_OP expression .)
    COMP_OP         reduce using rule 18 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 18 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 18 (expression -> expression ADD_OP expression .)
    )               reduce using rule 18 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 18 (expression -> expression ADD_OP expression .)
    ]               reduce using rule 18 (expression -> expression ADD_OP expression .)
    {               reduce using rule 18 (expression -> expression ADD_OP expression .)
    }               reduce using rule 18 (expression -> expression ADD_OP expression .)
    TO              reduce using rule 18 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 21

  ! MUL_OP          [ reduce using rule 18 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 20 ]
  ! COMP_OP         [ shift and go to state 22 ]


state 38

    (19) expression -> expression MUL_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 19 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 19 (expression -> expression MUL_OP expression .)
    COMP_OP         reduce using rule 19 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 19 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 19 (expression -> expression MUL_OP expression .)
    )               reduce using rule 19 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 19 (expression -> expression MUL_OP expression .)
    ]               reduce using rule 19 (expression -> expression MUL_OP expression .)
    {               reduce using rule 19 (expression -> expression MUL_OP expression .)
    }               reduce using rule 19 (expression -> expression MUL_OP expression .)
    TO              reduce using rule 19 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 20 ]
  ! MUL_OP          [ shift and go to state 21 ]
  ! COMP_OP         [ shift and go to state 22 ]


state 39

    (20) expression -> expression COMP_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    COMP_OP         reduce using rule 20 (expression -> expression COMP_OP expression .)
    ;               reduce using rule 20 (expression -> expression COMP_OP expression .)
    $end            reduce using rule 20 (expression -> expression COMP_OP expression .)
    )               reduce using rule 20 (expression -> expression COMP_OP expression .)
    ,               reduce using rule 20 (expression -> expression COMP_OP expression .)
    ]               reduce using rule 20 (expression -> expression COMP_OP expression .)
    {               reduce using rule 20 (expression -> expression COMP_OP expression .)
    }               reduce using rule 20 (expression -> expression COMP_OP expression .)
    TO              reduce using rule 20 (expression -> expression COMP_OP expression .)
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21

  ! ADD_OP          [ reduce using rule 20 (expression -> expression COMP_OP expression .) ]
  ! MUL_OP          [ reduce using rule 20 (expression -> expression COMP_OP expression .) ]
  ! COMP_OP         [ shift and go to state 22 ]


state 40

    (21) assignation -> IDENTIFIER = expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    ;               reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 21 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 41

    (24) expression -> IDENTIFIER [ IDENTIFIER . ]

    ]               shift and go to state 52


state 42

    (23) function -> IDENTIFIER ( parameter . )

    )               shift and go to state 53


state 43

    (12) expression -> ( expression ) .

    ADD_OP          reduce using rule 12 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 12 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 12 (expression -> ( expression ) .)
    ;               reduce using rule 12 (expression -> ( expression ) .)
    $end            reduce using rule 12 (expression -> ( expression ) .)
    )               reduce using rule 12 (expression -> ( expression ) .)
    ,               reduce using rule 12 (expression -> ( expression ) .)
    ]               reduce using rule 12 (expression -> ( expression ) .)
    {               reduce using rule 12 (expression -> ( expression ) .)
    }               reduce using rule 12 (expression -> ( expression ) .)
    TO              reduce using rule 12 (expression -> ( expression ) .)


state 44

    (22) array -> [ parameter ] .

    ADD_OP          reduce using rule 22 (array -> [ parameter ] .)
    MUL_OP          reduce using rule 22 (array -> [ parameter ] .)
    COMP_OP         reduce using rule 22 (array -> [ parameter ] .)
    ;               reduce using rule 22 (array -> [ parameter ] .)
    $end            reduce using rule 22 (array -> [ parameter ] .)
    )               reduce using rule 22 (array -> [ parameter ] .)
    ,               reduce using rule 22 (array -> [ parameter ] .)
    ]               reduce using rule 22 (array -> [ parameter ] .)
    {               reduce using rule 22 (array -> [ parameter ] .)
    }               reduce using rule 22 (array -> [ parameter ] .)
    TO              reduce using rule 22 (array -> [ parameter ] .)


state 45

    (26) parameter -> expression , . parameter
    (25) parameter -> . expression
    (26) parameter -> . expression , parameter
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 29
    parameter                      shift and go to state 54
    array                          shift and go to state 10
    function                       shift and go to state 11

state 46

    (6) structure -> WHILE expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    expression                     shift and go to state 4
    programme                      shift and go to state 55
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 47

    (7) structure -> FOR IDENTIFIER FROM . expression TO expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 56
    array                          shift and go to state 10
    function                       shift and go to state 11

state 48

    (8) structure -> IF expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    expression                     shift and go to state 4
    programme                      shift and go to state 57
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 49

    (9) structure -> BULLETEDLIST { programme . }

    }               shift and go to state 58


state 50

    (10) structure -> TABLE { programme . }

    }               shift and go to state 59


state 51

    (11) structure -> TABLEROW { programme . }

    }               shift and go to state 60


state 52

    (24) expression -> IDENTIFIER [ IDENTIFIER ] .

    ADD_OP          reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    MUL_OP          reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    COMP_OP         reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    ;               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    $end            reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    )               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    ,               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    ]               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    {               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    }               reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)
    TO              reduce using rule 24 (expression -> IDENTIFIER [ IDENTIFIER ] .)


state 53

    (23) function -> IDENTIFIER ( parameter ) .

    ADD_OP          reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    MUL_OP          reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    COMP_OP         reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    ;               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    $end            reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    )               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    ,               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    ]               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    {               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    }               reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)
    TO              reduce using rule 23 (function -> IDENTIFIER ( parameter ) .)


state 54

    (26) parameter -> expression , parameter .

    ]               reduce using rule 26 (parameter -> expression , parameter .)
    )               reduce using rule 26 (parameter -> expression , parameter .)


state 55

    (6) structure -> WHILE expression { programme . }

    }               shift and go to state 61


state 56

    (7) structure -> FOR IDENTIFIER FROM expression . TO expression { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    TO              shift and go to state 62
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 57

    (8) structure -> IF expression { programme . }

    }               shift and go to state 63


state 58

    (9) structure -> BULLETEDLIST { programme } .

    ;               reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    $end            reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    }               reduce using rule 9 (structure -> BULLETEDLIST { programme } .)


state 59

    (10) structure -> TABLE { programme } .

    ;               reduce using rule 10 (structure -> TABLE { programme } .)
    $end            reduce using rule 10 (structure -> TABLE { programme } .)
    }               reduce using rule 10 (structure -> TABLE { programme } .)


state 60

    (11) structure -> TABLEROW { programme } .

    ;               reduce using rule 11 (structure -> TABLEROW { programme } .)
    $end            reduce using rule 11 (structure -> TABLEROW { programme } .)
    }               reduce using rule 11 (structure -> TABLEROW { programme } .)


state 61

    (6) structure -> WHILE expression { programme } .

    ;               reduce using rule 6 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 6 (structure -> WHILE expression { programme } .)
    }               reduce using rule 6 (structure -> WHILE expression { programme } .)


state 62

    (7) structure -> FOR IDENTIFIER FROM expression TO . expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    IDENTIFIER      shift and go to state 27
    [               shift and go to state 12

    expression                     shift and go to state 64
    array                          shift and go to state 10
    function                       shift and go to state 11

state 63

    (8) structure -> IF expression { programme } .

    ;               reduce using rule 8 (structure -> IF expression { programme } .)
    $end            reduce using rule 8 (structure -> IF expression { programme } .)
    }               reduce using rule 8 (structure -> IF expression { programme } .)


state 64

    (7) structure -> FOR IDENTIFIER FROM expression TO expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression
    (20) expression -> expression . COMP_OP expression

    {               shift and go to state 65
    ADD_OP          shift and go to state 20
    MUL_OP          shift and go to state 21
    COMP_OP         shift and go to state 22


state 65

    (7) structure -> FOR IDENTIFIER FROM expression TO expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . expression
    (5) statement -> . structure
    (21) assignation -> . IDENTIFIER = expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . array
    (16) expression -> . function
    (17) expression -> . IDENTIFIER
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . expression COMP_OP expression
    (24) expression -> . IDENTIFIER [ IDENTIFIER ]
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM expression TO expression { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . TABLE { programme }
    (11) structure -> . TABLEROW { programme }
    (22) array -> . [ parameter ]
    (23) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    (               shift and go to state 7
    NUMBER          shift and go to state 8
    STRING          shift and go to state 9
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    IF              shift and go to state 15
    BULLETEDLIST    shift and go to state 16
    TABLE           shift and go to state 17
    TABLEROW        shift and go to state 18
    [               shift and go to state 12

    expression                     shift and go to state 4
    programme                      shift and go to state 66
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 5
    array                          shift and go to state 10
    function                       shift and go to state 11

state 66

    (7) structure -> FOR IDENTIFIER FROM expression TO expression { programme . }

    }               shift and go to state 67


state 67

    (7) structure -> FOR IDENTIFIER FROM expression TO expression { programme } .

    ;               reduce using rule 7 (structure -> FOR IDENTIFIER FROM expression TO expression { programme } .)
    $end            reduce using rule 7 (structure -> FOR IDENTIFIER FROM expression TO expression { programme } .)
    }               reduce using rule 7 (structure -> FOR IDENTIFIER FROM expression TO expression { programme } .)

