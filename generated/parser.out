Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation
Rule 4     statement -> structure
Rule 5     statement -> function
Rule 6     structure -> WHILE expression { programme }
Rule 7     structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
Rule 8     structure -> IF expression { programme }
Rule 9     structure -> BULLETEDLIST { programme }
Rule 10    structure -> ARRAY { programme }
Rule 11    structure -> ARRAYROW { programme }
Rule 12    expression -> ( expression )
Rule 13    expression -> NUMBER
Rule 14    expression -> STRING
Rule 15    expression -> IDENTIFIER
Rule 16    expression -> expression ADD_OP expression
Rule 17    expression -> expression MUL_OP expression
Rule 18    expression -> expression COMP_OP expression
Rule 19    assignation -> IDENTIFIER = expression
Rule 20    parameter -> expression
Rule 21    parameter -> expression , parameter
Rule 22    function -> IDENTIFIER ( parameter )

Terminals, with rules where they appear

(                    : 12 22
)                    : 12 22
,                    : 21
;                    : 2
=                    : 19
ADD_OP               : 16
ARRAY                : 10
ARRAYROW             : 11
BULLETEDLIST         : 9
COMP_OP              : 18
FOR                  : 7
FROM                 : 7
IDENTIFIER           : 7 15 19 22
IF                   : 8
MUL_OP               : 17
NUMBER               : 7 7 13
STRING               : 14
TO                   : 7
WHILE                : 6
error                : 
{                    : 6 7 8 9 10 11
}                    : 6 7 8 9 10 11

Nonterminals, with rules where they appear

assignation          : 3
expression           : 6 8 12 16 16 17 17 18 18 19 20 21
function             : 5
parameter            : 21 22
programme            : 2 6 7 8 9 10 11 0
statement            : 1 2
structure            : 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . ; programme

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 13


state 3

    (3) statement -> assignation .

    ;               reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> structure .

    ;               reduce using rule 4 (statement -> structure .)
    $end            reduce using rule 4 (statement -> structure .)
    }               reduce using rule 4 (statement -> structure .)


state 5

    (5) statement -> function .

    ;               reduce using rule 5 (statement -> function .)
    $end            reduce using rule 5 (statement -> function .)
    }               reduce using rule 5 (statement -> function .)


state 6

    (19) assignation -> IDENTIFIER . = expression
    (22) function -> IDENTIFIER . ( parameter )

    =               shift and go to state 14
    (               shift and go to state 15


state 7

    (6) structure -> WHILE . expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 16

state 8

    (7) structure -> FOR . IDENTIFIER FROM NUMBER TO NUMBER { programme }

    IDENTIFIER      shift and go to state 21


state 9

    (8) structure -> IF . expression { programme }
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 22

state 10

    (9) structure -> BULLETEDLIST . { programme }

    {               shift and go to state 23


state 11

    (10) structure -> ARRAY . { programme }

    {               shift and go to state 24


state 12

    (11) structure -> ARRAYROW . { programme }

    {               shift and go to state 25


state 13

    (2) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    statement                      shift and go to state 2
    programme                      shift and go to state 26
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 14

    (19) assignation -> IDENTIFIER = . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 27

state 15

    (22) function -> IDENTIFIER ( . parameter )
    (20) parameter -> . expression
    (21) parameter -> . expression , parameter
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    parameter                      shift and go to state 28
    expression                     shift and go to state 29

state 16

    (6) structure -> WHILE expression . { programme }
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    {               shift and go to state 30
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32
    COMP_OP         shift and go to state 33


state 17

    (12) expression -> ( . expression )
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 34

state 18

    (13) expression -> NUMBER .

    {               reduce using rule 13 (expression -> NUMBER .)
    ADD_OP          reduce using rule 13 (expression -> NUMBER .)
    MUL_OP          reduce using rule 13 (expression -> NUMBER .)
    COMP_OP         reduce using rule 13 (expression -> NUMBER .)
    ;               reduce using rule 13 (expression -> NUMBER .)
    $end            reduce using rule 13 (expression -> NUMBER .)
    }               reduce using rule 13 (expression -> NUMBER .)
    ,               reduce using rule 13 (expression -> NUMBER .)
    )               reduce using rule 13 (expression -> NUMBER .)


state 19

    (14) expression -> STRING .

    {               reduce using rule 14 (expression -> STRING .)
    ADD_OP          reduce using rule 14 (expression -> STRING .)
    MUL_OP          reduce using rule 14 (expression -> STRING .)
    COMP_OP         reduce using rule 14 (expression -> STRING .)
    ;               reduce using rule 14 (expression -> STRING .)
    $end            reduce using rule 14 (expression -> STRING .)
    }               reduce using rule 14 (expression -> STRING .)
    ,               reduce using rule 14 (expression -> STRING .)
    )               reduce using rule 14 (expression -> STRING .)


state 20

    (15) expression -> IDENTIFIER .

    {               reduce using rule 15 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 15 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 15 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 15 (expression -> IDENTIFIER .)
    ;               reduce using rule 15 (expression -> IDENTIFIER .)
    $end            reduce using rule 15 (expression -> IDENTIFIER .)
    }               reduce using rule 15 (expression -> IDENTIFIER .)
    ,               reduce using rule 15 (expression -> IDENTIFIER .)
    )               reduce using rule 15 (expression -> IDENTIFIER .)


state 21

    (7) structure -> FOR IDENTIFIER . FROM NUMBER TO NUMBER { programme }

    FROM            shift and go to state 35


state 22

    (8) structure -> IF expression . { programme }
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    {               shift and go to state 36
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32
    COMP_OP         shift and go to state 33


state 23

    (9) structure -> BULLETEDLIST { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 37
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 24

    (10) structure -> ARRAY { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 38
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 25

    (11) structure -> ARRAYROW { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 39
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 26

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 27

    (19) assignation -> IDENTIFIER = expression .
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    ;               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 19 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32
    COMP_OP         shift and go to state 33


state 28

    (22) function -> IDENTIFIER ( parameter . )

    )               shift and go to state 40


state 29

    (20) parameter -> expression .
    (21) parameter -> expression . , parameter
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    )               reduce using rule 20 (parameter -> expression .)
    ,               shift and go to state 41
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32
    COMP_OP         shift and go to state 33


state 30

    (6) structure -> WHILE expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 42
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 31

    (16) expression -> expression ADD_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 43

state 32

    (17) expression -> expression MUL_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 44

state 33

    (18) expression -> expression COMP_OP . expression
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 45

state 34

    (12) expression -> ( expression . )
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    )               shift and go to state 46
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32
    COMP_OP         shift and go to state 33


state 35

    (7) structure -> FOR IDENTIFIER FROM . NUMBER TO NUMBER { programme }

    NUMBER          shift and go to state 47


state 36

    (8) structure -> IF expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 48
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 37

    (9) structure -> BULLETEDLIST { programme . }

    }               shift and go to state 49


state 38

    (10) structure -> ARRAY { programme . }

    }               shift and go to state 50


state 39

    (11) structure -> ARRAYROW { programme . }

    }               shift and go to state 51


state 40

    (22) function -> IDENTIFIER ( parameter ) .

    ;               reduce using rule 22 (function -> IDENTIFIER ( parameter ) .)
    $end            reduce using rule 22 (function -> IDENTIFIER ( parameter ) .)
    }               reduce using rule 22 (function -> IDENTIFIER ( parameter ) .)


state 41

    (21) parameter -> expression , . parameter
    (20) parameter -> . expression
    (21) parameter -> . expression , parameter
    (12) expression -> . ( expression )
    (13) expression -> . NUMBER
    (14) expression -> . STRING
    (15) expression -> . IDENTIFIER
    (16) expression -> . expression ADD_OP expression
    (17) expression -> . expression MUL_OP expression
    (18) expression -> . expression COMP_OP expression

    (               shift and go to state 17
    NUMBER          shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 20

    expression                     shift and go to state 29
    parameter                      shift and go to state 52

state 42

    (6) structure -> WHILE expression { programme . }

    }               shift and go to state 53


state 43

    (16) expression -> expression ADD_OP expression .
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    {               reduce using rule 16 (expression -> expression ADD_OP expression .)
    ADD_OP          reduce using rule 16 (expression -> expression ADD_OP expression .)
    COMP_OP         reduce using rule 16 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 16 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 16 (expression -> expression ADD_OP expression .)
    }               reduce using rule 16 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 16 (expression -> expression ADD_OP expression .)
    )               reduce using rule 16 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 32

  ! MUL_OP          [ reduce using rule 16 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 31 ]
  ! COMP_OP         [ shift and go to state 33 ]


state 44

    (17) expression -> expression MUL_OP expression .
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    {               reduce using rule 17 (expression -> expression MUL_OP expression .)
    ADD_OP          reduce using rule 17 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 17 (expression -> expression MUL_OP expression .)
    COMP_OP         reduce using rule 17 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 17 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 17 (expression -> expression MUL_OP expression .)
    }               reduce using rule 17 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 17 (expression -> expression MUL_OP expression .)
    )               reduce using rule 17 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 31 ]
  ! MUL_OP          [ shift and go to state 32 ]
  ! COMP_OP         [ shift and go to state 33 ]


state 45

    (18) expression -> expression COMP_OP expression .
    (16) expression -> expression . ADD_OP expression
    (17) expression -> expression . MUL_OP expression
    (18) expression -> expression . COMP_OP expression

    {               reduce using rule 18 (expression -> expression COMP_OP expression .)
    COMP_OP         reduce using rule 18 (expression -> expression COMP_OP expression .)
    ;               reduce using rule 18 (expression -> expression COMP_OP expression .)
    $end            reduce using rule 18 (expression -> expression COMP_OP expression .)
    }               reduce using rule 18 (expression -> expression COMP_OP expression .)
    ,               reduce using rule 18 (expression -> expression COMP_OP expression .)
    )               reduce using rule 18 (expression -> expression COMP_OP expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32

  ! ADD_OP          [ reduce using rule 18 (expression -> expression COMP_OP expression .) ]
  ! MUL_OP          [ reduce using rule 18 (expression -> expression COMP_OP expression .) ]
  ! COMP_OP         [ shift and go to state 33 ]


state 46

    (12) expression -> ( expression ) .

    {               reduce using rule 12 (expression -> ( expression ) .)
    ADD_OP          reduce using rule 12 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 12 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 12 (expression -> ( expression ) .)
    ;               reduce using rule 12 (expression -> ( expression ) .)
    $end            reduce using rule 12 (expression -> ( expression ) .)
    }               reduce using rule 12 (expression -> ( expression ) .)
    ,               reduce using rule 12 (expression -> ( expression ) .)
    )               reduce using rule 12 (expression -> ( expression ) .)


state 47

    (7) structure -> FOR IDENTIFIER FROM NUMBER . TO NUMBER { programme }

    TO              shift and go to state 54


state 48

    (8) structure -> IF expression { programme . }

    }               shift and go to state 55


state 49

    (9) structure -> BULLETEDLIST { programme } .

    ;               reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    $end            reduce using rule 9 (structure -> BULLETEDLIST { programme } .)
    }               reduce using rule 9 (structure -> BULLETEDLIST { programme } .)


state 50

    (10) structure -> ARRAY { programme } .

    ;               reduce using rule 10 (structure -> ARRAY { programme } .)
    $end            reduce using rule 10 (structure -> ARRAY { programme } .)
    }               reduce using rule 10 (structure -> ARRAY { programme } .)


state 51

    (11) structure -> ARRAYROW { programme } .

    ;               reduce using rule 11 (structure -> ARRAYROW { programme } .)
    $end            reduce using rule 11 (structure -> ARRAYROW { programme } .)
    }               reduce using rule 11 (structure -> ARRAYROW { programme } .)


state 52

    (21) parameter -> expression , parameter .

    )               reduce using rule 21 (parameter -> expression , parameter .)


state 53

    (6) structure -> WHILE expression { programme } .

    ;               reduce using rule 6 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 6 (structure -> WHILE expression { programme } .)
    }               reduce using rule 6 (structure -> WHILE expression { programme } .)


state 54

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO . NUMBER { programme }

    NUMBER          shift and go to state 56


state 55

    (8) structure -> IF expression { programme } .

    ;               reduce using rule 8 (structure -> IF expression { programme } .)
    $end            reduce using rule 8 (structure -> IF expression { programme } .)
    }               reduce using rule 8 (structure -> IF expression { programme } .)


state 56

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER . { programme }

    {               shift and go to state 57


state 57

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { . programme }
    (1) programme -> . statement
    (2) programme -> . statement ; programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . function
    (19) assignation -> . IDENTIFIER = expression
    (6) structure -> . WHILE expression { programme }
    (7) structure -> . FOR IDENTIFIER FROM NUMBER TO NUMBER { programme }
    (8) structure -> . IF expression { programme }
    (9) structure -> . BULLETEDLIST { programme }
    (10) structure -> . ARRAY { programme }
    (11) structure -> . ARRAYROW { programme }
    (22) function -> . IDENTIFIER ( parameter )

    IDENTIFIER      shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    IF              shift and go to state 9
    BULLETEDLIST    shift and go to state 10
    ARRAY           shift and go to state 11
    ARRAYROW        shift and go to state 12

    programme                      shift and go to state 58
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4
    function                       shift and go to state 5

state 58

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme . }

    }               shift and go to state 59


state 59

    (7) structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .

    ;               reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)
    $end            reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)
    }               reduce using rule 7 (structure -> FOR IDENTIFIER FROM NUMBER TO NUMBER { programme } .)

